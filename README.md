# normal_linux_programming

「ふつうのLinuxプログラム」の読書ログ

* /usrは、User Service and Resourceの略で、全ユーザ（ホスト）で共通のファイルを置いておく場所。一方で/usr/localはユーザ別。
* /procにプロセス別の情報が揃っている。システムのリソース情報もある。
* set-uidを利用すると、`-rws------`みたいな感じで、実行権限のところがxからsになる。そうすると、このファイルの実行時、その実行者（実効ユーザ, effective user）はファイルのオーナーになる。gidを利用すれば、group単位で同じことができる。
* processはforkして増やすことができる。子プロセスの実効結果を、wait()を利用して待つ。子プロセスは祖プロセスが終了した時点で消えるので、waitを忘れてもゴミが残らないが、daemonプロセスなどの常駐プロセスで子プロセスの管理をミスると、ゴミ（ゾンビプロセス）が溜まっていく。これを防ぐ方法として、複製したプロセスを孫プロセスとすることで、確実に消去するという方法がある（プロセスは、祖プロセスがなければ自動で終了される。子プロセスから孫プロセスをforkし、子プロセスはすぐにexitすれば良い）
* 標準エラー出力は、人間用のファイルディスクリプタ。標準出力に含めると、パイプなどで次のプロセスに送られてしまうので、標準エラー出力が用意されている。
* wコマンドやlastコマンドで、最新のログイン情報を確認できる。
* ログイン認証のためのPAM（Pluggable Authentication Module）というものがある。
* LDAPなどで認証情報をまとめておけば、複数端末で認証情報を共有できる。`/etc/nsswitch.conf`に設定が書かれている。
* `ln a b`で、aが指すファイルをbもリンクすることができる。シンボリックリンクのようなノリで、ダイナミックリンクと呼ばれる。これをやると、aの指していたファイルの参照数が2になる。`rm`コマンドでは、このリンクを削除しており、実体ファイルを削除しているわけではない。実体ファイルは、参照数が0になった時に自動的に削除される。
* `ls -l`の時のinodeの先頭文字の意味は以下.
    ```file
    d  directory
    l  symlink
    c  char device
    b  block device
    p  pipe
    s  socket
    ```
* 環境変数は、`**environ`に、`XXX=xxxx`の形式で保存されている。
  * `putenv`で設定する場合、設定したポインタがなくならないように、静的な領域に用意した文字列をセットするか、mallocで確保した領域に用意した文字列を渡す。`setenv`なら値がコピーされれ、変数の管理がOS側に移るので、基本は`setenv`が良い。
* `ls -ld dir`で、dirの情報を見ることができる。
* 親子のプロセスでは同じFDを共有する。
* `/etc/services`にポートごとのサービス名が乗ってる。
* 0-1023は特権ポート。元々superuserでしか割当てできなかった。
* `mkfifo`コマンドで、名前付きパイプを作成できる。
* `ulimit -n`コマンドで、FDの上限を確認できる。
* `socket`で、指定したプロトコル用のソケット（FD）を用意し、`connect`で指定したIP:portに接続を試みる。
  * 詳しくは`man socket`
  * サーバ側は、`socket, bind, listen, accept`
* ディレクトリの参照数が2とか3になってる件は、(2 + サブディレクトリの数)が参照数になるからである。
  * `.`や、サブディレクトリの`subdir/..`がリンクされるため。
* httpリクエストを並列に捌く方法として、pre-forkか、concurrentの方式がある。pre-forkは事前にforkして複数のプロセスを作っておいて、それぞれでacceptする方式。concurrentはacceptしてからforkする方式。基本的にはシンプルなconcurrent方式でほとんど問題がない。高スループットなどが必要な場合、pre-forkが適しているかもしれないが、pre-forkに関わる設定が複雑なため、実装難易度が高い。
* 長時間動作するデーモンは、できるだけルートディレクトリに移動するべき。
  * プロセスがカレントディレクトリにしているファイルシステムはアンマウントできないため。
* デーモンプロセスでは標準入出力は利用できないので、ログファイルに書き込みを行う。syslogというAPIを利用すると便利。
  * レベルに応じて、`/var/log/messages`や`/var/log/syslog`に保存される。